<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>RDoc Documentation</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "./";
  var index_rel_prefix = "./";
</script>

<script src="./js/navigation.js" defer></script>
<script src="./js/search.js" defer></script>
<script src="./js/search_index.js" defer></script>
<script src="./js/searcher.js" defer></script>
<script src="./js/darkfish.js" defer></script>

<link href="./css/fonts.css" rel="stylesheet">
<link href="./css/rdoc.css" rel="stylesheet">


<body id="top" role="document" class="file">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="./index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="./table_of_contents.html#pages">Pages</a>
    <a href="./table_of_contents.html#classes">Classes</a>
    <a href="./table_of_contents.html#methods">Methods</a>
  </div>
</div>


    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  <div id="project-metadata">
    
<div id="fileindex-section" class="nav-section">
  <h3>Pages</h3>

  <ul class="link-list">
    <li><a href="./CHANGELOG_md.html">CHANGELOG</a>
    <li><a href="./CODE_OF_CONDUCT_md.html">CODE_OF_CONDUCT</a>
    <li><a href="./LICENSE.html">LICENSE</a>
    <li><a href="./README_md.html">README</a>
  </ul>
</div>

    <div id="classindex-section" class="nav-section">
  <h3>Class and Module Index</h3>

  <ul class="link-list">
    <li><a href="./PrettyPrint.html">PrettyPrint</a>
    <li><a href="./PrettyPrint/Align.html">PrettyPrint::Align</a>
    <li><a href="./PrettyPrint/BreakParent.html">PrettyPrint::BreakParent</a>
    <li><a href="./PrettyPrint/Breakable.html">PrettyPrint::Breakable</a>
    <li><a href="./PrettyPrint/Buffer.html">PrettyPrint::Buffer</a>
    <li><a href="./PrettyPrint/Buffer/ArrayBuffer.html">PrettyPrint::Buffer::ArrayBuffer</a>
    <li><a href="./PrettyPrint/Buffer/DefaultBuffer.html">PrettyPrint::Buffer::DefaultBuffer</a>
    <li><a href="./PrettyPrint/Buffer/StringBuffer.html">PrettyPrint::Buffer::StringBuffer</a>
    <li><a href="./PrettyPrint/Group.html">PrettyPrint::Group</a>
    <li><a href="./PrettyPrint/IfBreak.html">PrettyPrint::IfBreak</a>
    <li><a href="./PrettyPrint/IfBreakBuilder.html">PrettyPrint::IfBreakBuilder</a>
    <li><a href="./PrettyPrint/Indent.html">PrettyPrint::Indent</a>
    <li><a href="./PrettyPrint/IndentLevel.html">PrettyPrint::IndentLevel</a>
    <li><a href="./PrettyPrint/LineSuffix.html">PrettyPrint::LineSuffix</a>
    <li><a href="./PrettyPrint/SingleLine.html">PrettyPrint::SingleLine</a>
    <li><a href="./PrettyPrint/SingleLine/IfBreakBuilder.html">PrettyPrint::SingleLine::IfBreakBuilder</a>
    <li><a href="./PrettyPrint/Text.html">PrettyPrint::Text</a>
    <li><a href="./PrettyPrint/Trim.html">PrettyPrint::Trim</a>
    <li><a href="./SyntaxTree.html">SyntaxTree</a>
    <li><a href="./SyntaxTree/ARef.html">SyntaxTree::ARef</a>
    <li><a href="./SyntaxTree/ARefField.html">SyntaxTree::ARefField</a>
    <li><a href="./SyntaxTree/Alias.html">SyntaxTree::Alias</a>
    <li><a href="./SyntaxTree/Alias/AliasArgumentFormatter.html">SyntaxTree::Alias::AliasArgumentFormatter</a>
    <li><a href="./SyntaxTree/ArgBlock.html">SyntaxTree::ArgBlock</a>
    <li><a href="./SyntaxTree/ArgParen.html">SyntaxTree::ArgParen</a>
    <li><a href="./SyntaxTree/ArgStar.html">SyntaxTree::ArgStar</a>
    <li><a href="./SyntaxTree/Args.html">SyntaxTree::Args</a>
    <li><a href="./SyntaxTree/ArgsForward.html">SyntaxTree::ArgsForward</a>
    <li><a href="./SyntaxTree/ArrayLiteral.html">SyntaxTree::ArrayLiteral</a>
    <li><a href="./SyntaxTree/ArrayLiteral/QSymbolsFormatter.html">SyntaxTree::ArrayLiteral::QSymbolsFormatter</a>
    <li><a href="./SyntaxTree/ArrayLiteral/QWordsFormatter.html">SyntaxTree::ArrayLiteral::QWordsFormatter</a>
    <li><a href="./SyntaxTree/ArrayLiteral/VarRefsFormatter.html">SyntaxTree::ArrayLiteral::VarRefsFormatter</a>
    <li><a href="./SyntaxTree/AryPtn.html">SyntaxTree::AryPtn</a>
    <li><a href="./SyntaxTree/AryPtn/RestFormatter.html">SyntaxTree::AryPtn::RestFormatter</a>
    <li><a href="./SyntaxTree/Assign.html">SyntaxTree::Assign</a>
    <li><a href="./SyntaxTree/AssignFormatting.html">SyntaxTree::AssignFormatting</a>
    <li><a href="./SyntaxTree/Assoc.html">SyntaxTree::Assoc</a>
    <li><a href="./SyntaxTree/AssocSplat.html">SyntaxTree::AssocSplat</a>
    <li><a href="./SyntaxTree/BEGINBlock.html">SyntaxTree::BEGINBlock</a>
    <li><a href="./SyntaxTree/Backref.html">SyntaxTree::Backref</a>
    <li><a href="./SyntaxTree/Backtick.html">SyntaxTree::Backtick</a>
    <li><a href="./SyntaxTree/BareAssocHash.html">SyntaxTree::BareAssocHash</a>
    <li><a href="./SyntaxTree/Begin.html">SyntaxTree::Begin</a>
    <li><a href="./SyntaxTree/Binary.html">SyntaxTree::Binary</a>
    <li><a href="./SyntaxTree/BlockArg.html">SyntaxTree::BlockArg</a>
    <li><a href="./SyntaxTree/BlockFormatter.html">SyntaxTree::BlockFormatter</a>
    <li><a href="./SyntaxTree/BlockFormatter/BlockOpenFormatter.html">SyntaxTree::BlockFormatter::BlockOpenFormatter</a>
    <li><a href="./SyntaxTree/BlockVar.html">SyntaxTree::BlockVar</a>
    <li><a href="./SyntaxTree/BodyStmt.html">SyntaxTree::BodyStmt</a>
    <li><a href="./SyntaxTree/BraceBlock.html">SyntaxTree::BraceBlock</a>
    <li><a href="./SyntaxTree/Break.html">SyntaxTree::Break</a>
    <li><a href="./SyntaxTree/CHAR.html">SyntaxTree::CHAR</a>
    <li><a href="./SyntaxTree/CLI.html">SyntaxTree::CLI</a>
    <li><a href="./SyntaxTree/CLI/AST.html">SyntaxTree::CLI::AST</a>
    <li><a href="./SyntaxTree/CLI/Action.html">SyntaxTree::CLI::Action</a>
    <li><a href="./SyntaxTree/CLI/Check.html">SyntaxTree::CLI::Check</a>
    <li><a href="./SyntaxTree/CLI/Check/UnformattedError.html">SyntaxTree::CLI::Check::UnformattedError</a>
    <li><a href="./SyntaxTree/CLI/Color.html">SyntaxTree::CLI::Color</a>
    <li><a href="./SyntaxTree/CLI/Debug.html">SyntaxTree::CLI::Debug</a>
    <li><a href="./SyntaxTree/CLI/Debug/NonIdempotentFormatError.html">SyntaxTree::CLI::Debug::NonIdempotentFormatError</a>
    <li><a href="./SyntaxTree/CLI/Doc.html">SyntaxTree::CLI::Doc</a>
    <li><a href="./SyntaxTree/CLI/Format.html">SyntaxTree::CLI::Format</a>
    <li><a href="./SyntaxTree/CLI/Write.html">SyntaxTree::CLI::Write</a>
    <li><a href="./SyntaxTree/CVar.html">SyntaxTree::CVar</a>
    <li><a href="./SyntaxTree/Call.html">SyntaxTree::Call</a>
    <li><a href="./SyntaxTree/CallOperatorFormatter.html">SyntaxTree::CallOperatorFormatter</a>
    <li><a href="./SyntaxTree/Case.html">SyntaxTree::Case</a>
    <li><a href="./SyntaxTree/ClassDeclaration.html">SyntaxTree::ClassDeclaration</a>
    <li><a href="./SyntaxTree/Comma.html">SyntaxTree::Comma</a>
    <li><a href="./SyntaxTree/Command.html">SyntaxTree::Command</a>
    <li><a href="./SyntaxTree/CommandCall.html">SyntaxTree::CommandCall</a>
    <li><a href="./SyntaxTree/Comment.html">SyntaxTree::Comment</a>
    <li><a href="./SyntaxTree/Comment/List.html">SyntaxTree::Comment::List</a>
    <li><a href="./SyntaxTree/ConditionalFormatter.html">SyntaxTree::ConditionalFormatter</a>
    <li><a href="./SyntaxTree/ConditionalModFormatter.html">SyntaxTree::ConditionalModFormatter</a>
    <li><a href="./SyntaxTree/Const.html">SyntaxTree::Const</a>
    <li><a href="./SyntaxTree/ConstPathField.html">SyntaxTree::ConstPathField</a>
    <li><a href="./SyntaxTree/ConstPathRef.html">SyntaxTree::ConstPathRef</a>
    <li><a href="./SyntaxTree/ConstRef.html">SyntaxTree::ConstRef</a>
    <li><a href="./SyntaxTree/ContainsAssignment.html">SyntaxTree::ContainsAssignment</a>
    <li><a href="./SyntaxTree/Def.html">SyntaxTree::Def</a>
    <li><a href="./SyntaxTree/DefEndless.html">SyntaxTree::DefEndless</a>
    <li><a href="./SyntaxTree/Defined.html">SyntaxTree::Defined</a>
    <li><a href="./SyntaxTree/Defs.html">SyntaxTree::Defs</a>
    <li><a href="./SyntaxTree/DoBlock.html">SyntaxTree::DoBlock</a>
    <li><a href="./SyntaxTree/Dot2.html">SyntaxTree::Dot2</a>
    <li><a href="./SyntaxTree/Dot3.html">SyntaxTree::Dot3</a>
    <li><a href="./SyntaxTree/DotFormatter.html">SyntaxTree::DotFormatter</a>
    <li><a href="./SyntaxTree/DynaSymbol.html">SyntaxTree::DynaSymbol</a>
    <li><a href="./SyntaxTree/ENDBlock.html">SyntaxTree::ENDBlock</a>
    <li><a href="./SyntaxTree/Else.html">SyntaxTree::Else</a>
    <li><a href="./SyntaxTree/Elsif.html">SyntaxTree::Elsif</a>
    <li><a href="./SyntaxTree/EmbDoc.html">SyntaxTree::EmbDoc</a>
    <li><a href="./SyntaxTree/EmbExprBeg.html">SyntaxTree::EmbExprBeg</a>
    <li><a href="./SyntaxTree/EmbExprEnd.html">SyntaxTree::EmbExprEnd</a>
    <li><a href="./SyntaxTree/EmbVar.html">SyntaxTree::EmbVar</a>
    <li><a href="./SyntaxTree/EndContent.html">SyntaxTree::EndContent</a>
    <li><a href="./SyntaxTree/Ensure.html">SyntaxTree::Ensure</a>
    <li><a href="./SyntaxTree/ExcessedComma.html">SyntaxTree::ExcessedComma</a>
    <li><a href="./SyntaxTree/FCall.html">SyntaxTree::FCall</a>
    <li><a href="./SyntaxTree/Field.html">SyntaxTree::Field</a>
    <li><a href="./SyntaxTree/FloatLiteral.html">SyntaxTree::FloatLiteral</a>
    <li><a href="./SyntaxTree/FlowControlFormatter.html">SyntaxTree::FlowControlFormatter</a>
    <li><a href="./SyntaxTree/FndPtn.html">SyntaxTree::FndPtn</a>
    <li><a href="./SyntaxTree/For.html">SyntaxTree::For</a>
    <li><a href="./SyntaxTree/Formatter.html">SyntaxTree::Formatter</a>
    <li><a href="./SyntaxTree/GVar.html">SyntaxTree::GVar</a>
    <li><a href="./SyntaxTree/HashKeyFormatter.html">SyntaxTree::HashKeyFormatter</a>
    <li><a href="./SyntaxTree/HashKeyFormatter/Labels.html">SyntaxTree::HashKeyFormatter::Labels</a>
    <li><a href="./SyntaxTree/HashKeyFormatter/Rockets.html">SyntaxTree::HashKeyFormatter::Rockets</a>
    <li><a href="./SyntaxTree/HashLiteral.html">SyntaxTree::HashLiteral</a>
    <li><a href="./SyntaxTree/Heredoc.html">SyntaxTree::Heredoc</a>
    <li><a href="./SyntaxTree/HeredocBeg.html">SyntaxTree::HeredocBeg</a>
    <li><a href="./SyntaxTree/HshPtn.html">SyntaxTree::HshPtn</a>
    <li><a href="./SyntaxTree/HshPtn/KeywordFormatter.html">SyntaxTree::HshPtn::KeywordFormatter</a>
    <li><a href="./SyntaxTree/HshPtn/KeywordRestFormatter.html">SyntaxTree::HshPtn::KeywordRestFormatter</a>
    <li><a href="./SyntaxTree/IVar.html">SyntaxTree::IVar</a>
    <li><a href="./SyntaxTree/Ident.html">SyntaxTree::Ident</a>
    <li><a href="./SyntaxTree/If.html">SyntaxTree::If</a>
    <li><a href="./SyntaxTree/IfMod.html">SyntaxTree::IfMod</a>
    <li><a href="./SyntaxTree/IfOp.html">SyntaxTree::IfOp</a>
    <li><a href="./SyntaxTree/Imaginary.html">SyntaxTree::Imaginary</a>
    <li><a href="./SyntaxTree/In.html">SyntaxTree::In</a>
    <li><a href="./SyntaxTree/Int.html">SyntaxTree::Int</a>
    <li><a href="./SyntaxTree/JSONVisitor.html">SyntaxTree::JSONVisitor</a>
    <li><a href="./SyntaxTree/Kw.html">SyntaxTree::Kw</a>
    <li><a href="./SyntaxTree/KwRestParam.html">SyntaxTree::KwRestParam</a>
    <li><a href="./SyntaxTree/LBrace.html">SyntaxTree::LBrace</a>
    <li><a href="./SyntaxTree/LBracket.html">SyntaxTree::LBracket</a>
    <li><a href="./SyntaxTree/LParen.html">SyntaxTree::LParen</a>
    <li><a href="./SyntaxTree/Label.html">SyntaxTree::Label</a>
    <li><a href="./SyntaxTree/LabelEnd.html">SyntaxTree::LabelEnd</a>
    <li><a href="./SyntaxTree/Lambda.html">SyntaxTree::Lambda</a>
    <li><a href="./SyntaxTree/LanguageServer.html">SyntaxTree::LanguageServer</a>
    <li><a href="./SyntaxTree/LanguageServer/InlayHints.html">SyntaxTree::LanguageServer::InlayHints</a>
    <li><a href="./SyntaxTree/Location.html">SyntaxTree::Location</a>
    <li><a href="./SyntaxTree/LoopFormatter.html">SyntaxTree::LoopFormatter</a>
    <li><a href="./SyntaxTree/MAssign.html">SyntaxTree::MAssign</a>
    <li><a href="./SyntaxTree/MLHS.html">SyntaxTree::MLHS</a>
    <li><a href="./SyntaxTree/MLHSParen.html">SyntaxTree::MLHSParen</a>
    <li><a href="./SyntaxTree/MRHS.html">SyntaxTree::MRHS</a>
    <li><a href="./SyntaxTree/MethodAddBlock.html">SyntaxTree::MethodAddBlock</a>
    <li><a href="./SyntaxTree/ModuleDeclaration.html">SyntaxTree::ModuleDeclaration</a>
    <li><a href="./SyntaxTree/Next.html">SyntaxTree::Next</a>
    <li><a href="./SyntaxTree/Node.html">SyntaxTree::Node</a>
    <li><a href="./SyntaxTree/Not.html">SyntaxTree::Not</a>
    <li><a href="./SyntaxTree/Op.html">SyntaxTree::Op</a>
    <li><a href="./SyntaxTree/OpAssign.html">SyntaxTree::OpAssign</a>
    <li><a href="./SyntaxTree/Params.html">SyntaxTree::Params</a>
    <li><a href="./SyntaxTree/Params/KeywordFormatter.html">SyntaxTree::Params::KeywordFormatter</a>
    <li><a href="./SyntaxTree/Params/KeywordRestFormatter.html">SyntaxTree::Params::KeywordRestFormatter</a>
    <li><a href="./SyntaxTree/Params/OptionalFormatter.html">SyntaxTree::Params::OptionalFormatter</a>
    <li><a href="./SyntaxTree/Paren.html">SyntaxTree::Paren</a>
    <li><a href="./SyntaxTree/Parentheses.html">SyntaxTree::Parentheses</a>
    <li><a href="./SyntaxTree/Parser.html">SyntaxTree::Parser</a>
    <li><a href="./SyntaxTree/Parser/MultiByteString.html">SyntaxTree::Parser::MultiByteString</a>
    <li><a href="./SyntaxTree/Parser/ParseError.html">SyntaxTree::Parser::ParseError</a>
    <li><a href="./SyntaxTree/Parser/SingleByteString.html">SyntaxTree::Parser::SingleByteString</a>
    <li><a href="./SyntaxTree/Period.html">SyntaxTree::Period</a>
    <li><a href="./SyntaxTree/PinnedBegin.html">SyntaxTree::PinnedBegin</a>
    <li><a href="./SyntaxTree/PinnedVarRef.html">SyntaxTree::PinnedVarRef</a>
    <li><a href="./SyntaxTree/Program.html">SyntaxTree::Program</a>
    <li><a href="./SyntaxTree/QSymbols.html">SyntaxTree::QSymbols</a>
    <li><a href="./SyntaxTree/QSymbolsBeg.html">SyntaxTree::QSymbolsBeg</a>
    <li><a href="./SyntaxTree/QWords.html">SyntaxTree::QWords</a>
    <li><a href="./SyntaxTree/QWordsBeg.html">SyntaxTree::QWordsBeg</a>
    <li><a href="./SyntaxTree/Quotes.html">SyntaxTree::Quotes</a>
    <li><a href="./SyntaxTree/RAssign.html">SyntaxTree::RAssign</a>
    <li><a href="./SyntaxTree/RBrace.html">SyntaxTree::RBrace</a>
    <li><a href="./SyntaxTree/RBracket.html">SyntaxTree::RBracket</a>
    <li><a href="./SyntaxTree/RParen.html">SyntaxTree::RParen</a>
    <li><a href="./SyntaxTree/RationalLiteral.html">SyntaxTree::RationalLiteral</a>
    <li><a href="./SyntaxTree/Redo.html">SyntaxTree::Redo</a>
    <li><a href="./SyntaxTree/RegexpBeg.html">SyntaxTree::RegexpBeg</a>
    <li><a href="./SyntaxTree/RegexpContent.html">SyntaxTree::RegexpContent</a>
    <li><a href="./SyntaxTree/RegexpEnd.html">SyntaxTree::RegexpEnd</a>
    <li><a href="./SyntaxTree/RegexpLiteral.html">SyntaxTree::RegexpLiteral</a>
    <li><a href="./SyntaxTree/RemoveBreaks.html">SyntaxTree::RemoveBreaks</a>
    <li><a href="./SyntaxTree/Rescue.html">SyntaxTree::Rescue</a>
    <li><a href="./SyntaxTree/RescueEx.html">SyntaxTree::RescueEx</a>
    <li><a href="./SyntaxTree/RescueMod.html">SyntaxTree::RescueMod</a>
    <li><a href="./SyntaxTree/RestParam.html">SyntaxTree::RestParam</a>
    <li><a href="./SyntaxTree/Retry.html">SyntaxTree::Retry</a>
    <li><a href="./SyntaxTree/Return.html">SyntaxTree::Return</a>
    <li><a href="./SyntaxTree/Return0.html">SyntaxTree::Return0</a>
    <li><a href="./SyntaxTree/SClass.html">SyntaxTree::SClass</a>
    <li><a href="./SyntaxTree/Statements.html">SyntaxTree::Statements</a>
    <li><a href="./SyntaxTree/StringConcat.html">SyntaxTree::StringConcat</a>
    <li><a href="./SyntaxTree/StringContent.html">SyntaxTree::StringContent</a>
    <li><a href="./SyntaxTree/StringDVar.html">SyntaxTree::StringDVar</a>
    <li><a href="./SyntaxTree/StringEmbExpr.html">SyntaxTree::StringEmbExpr</a>
    <li><a href="./SyntaxTree/StringLiteral.html">SyntaxTree::StringLiteral</a>
    <li><a href="./SyntaxTree/Super.html">SyntaxTree::Super</a>
    <li><a href="./SyntaxTree/SymBeg.html">SyntaxTree::SymBeg</a>
    <li><a href="./SyntaxTree/SymbolContent.html">SyntaxTree::SymbolContent</a>
    <li><a href="./SyntaxTree/SymbolLiteral.html">SyntaxTree::SymbolLiteral</a>
    <li><a href="./SyntaxTree/Symbols.html">SyntaxTree::Symbols</a>
    <li><a href="./SyntaxTree/SymbolsBeg.html">SyntaxTree::SymbolsBeg</a>
    <li><a href="./SyntaxTree/TLamBeg.html">SyntaxTree::TLamBeg</a>
    <li><a href="./SyntaxTree/TLambda.html">SyntaxTree::TLambda</a>
    <li><a href="./SyntaxTree/TStringBeg.html">SyntaxTree::TStringBeg</a>
    <li><a href="./SyntaxTree/TStringContent.html">SyntaxTree::TStringContent</a>
    <li><a href="./SyntaxTree/TStringEnd.html">SyntaxTree::TStringEnd</a>
    <li><a href="./SyntaxTree/TopConstField.html">SyntaxTree::TopConstField</a>
    <li><a href="./SyntaxTree/TopConstRef.html">SyntaxTree::TopConstRef</a>
    <li><a href="./SyntaxTree/Unary.html">SyntaxTree::Unary</a>
    <li><a href="./SyntaxTree/Undef.html">SyntaxTree::Undef</a>
    <li><a href="./SyntaxTree/Undef/UndefArgumentFormatter.html">SyntaxTree::Undef::UndefArgumentFormatter</a>
    <li><a href="./SyntaxTree/Unless.html">SyntaxTree::Unless</a>
    <li><a href="./SyntaxTree/UnlessMod.html">SyntaxTree::UnlessMod</a>
    <li><a href="./SyntaxTree/Until.html">SyntaxTree::Until</a>
    <li><a href="./SyntaxTree/UntilMod.html">SyntaxTree::UntilMod</a>
    <li><a href="./SyntaxTree/VCall.html">SyntaxTree::VCall</a>
    <li><a href="./SyntaxTree/VarAlias.html">SyntaxTree::VarAlias</a>
    <li><a href="./SyntaxTree/VarField.html">SyntaxTree::VarField</a>
    <li><a href="./SyntaxTree/VarRef.html">SyntaxTree::VarRef</a>
    <li><a href="./SyntaxTree/Visitor.html">SyntaxTree::Visitor</a>
    <li><a href="./SyntaxTree/Visitor/VisitMethodChecker.html">SyntaxTree::Visitor::VisitMethodChecker</a>
    <li><a href="./SyntaxTree/Visitor/VisitMethodError.html">SyntaxTree::Visitor::VisitMethodError</a>
    <li><a href="./SyntaxTree/VoidStmt.html">SyntaxTree::VoidStmt</a>
    <li><a href="./SyntaxTree/When.html">SyntaxTree::When</a>
    <li><a href="./SyntaxTree/While.html">SyntaxTree::While</a>
    <li><a href="./SyntaxTree/WhileMod.html">SyntaxTree::WhileMod</a>
    <li><a href="./SyntaxTree/Word.html">SyntaxTree::Word</a>
    <li><a href="./SyntaxTree/Words.html">SyntaxTree::Words</a>
    <li><a href="./SyntaxTree/WordsBeg.html">SyntaxTree::WordsBeg</a>
    <li><a href="./SyntaxTree/XString.html">SyntaxTree::XString</a>
    <li><a href="./SyntaxTree/XStringLiteral.html">SyntaxTree::XStringLiteral</a>
    <li><a href="./SyntaxTree/Yield.html">SyntaxTree::Yield</a>
    <li><a href="./SyntaxTree/Yield0.html">SyntaxTree::Yield0</a>
    <li><a href="./SyntaxTree/ZSuper.html">SyntaxTree::ZSuper</a>
  </ul>
</div>

  </div>
</nav>

<main role="main">

<div align="center">
  <img alt="Syntax Tree" height="400px" src="./doc/logo.svg">
</div>
<h1 id="label-SyntaxTree"><a href="SyntaxTree.html"><code>SyntaxTree</code></a><span><a href="#label-SyntaxTree">&para;</a> <a href="#top">&uarr;</a></span></h1>

<p><a href="https://github.com/ruby-syntax-tree/syntax_tree/actions/workflows/main.yml"><img src="https://github.com/ruby-syntax-tree/syntax_tree/actions/workflows/main.yml/badge.svg"></a> <a href="https://rubygems.org/gems/syntax_tree"><img src="https://img.shields.io/gem/v/syntax_tree.svg"></a></p>

<p>Syntax Tree is a suite of tools built on top of the internal CRuby parser. It provides the ability to generate a syntax tree from source, as well as the tools necessary to inspect and manipulate that syntax tree. It can be used to build formatters, linters, language servers, and more.</p>

<p>It is built with only standard library dependencies. It additionally ships with a plugin system so that you can build your own syntax trees from other languages and incorporate these tools.</p>
<ul><li>
<p><a href="#installation">Installation</a></p>
</li><li>
<p><a href="#cli">CLI</a></p>
</li><li>
<p><a href="#ast">ast</a></p>
</li><li>
<p><a href="#check">check</a></p>
</li><li>
<p><a href="#format">format</a></p>
</li><li>
<p><a href="#write">write</a></p>
</li><li>
<p><a href="#library">Library</a></p>
</li><li>
<p><a href="#syntaxtreereadfilepath">SyntaxTree.read(filepath)</a></p>
</li><li>
<p><a href="#syntaxtreeparsesource">SyntaxTree.parse(source)</a></p>
</li><li>
<p><a href="#syntaxtreeformatsource">SyntaxTree.format(source)</a></p>
</li><li>
<p><a href="#nodes">Nodes</a></p>
</li><li>
<p><a href="#child_nodes">child_nodes</a></p>
</li><li>
<p><a href="#pattern-matching">Pattern matching</a></p>
</li><li>
<p><a href="#pretty_printq">pretty_print(q)</a></p>
</li><li>
<p><a href="#to_jsonopts">to_json(*opts)</a></p>
</li><li>
<p><a href="#formatq">format(q)</a></p>
</li><li>
<p><a href="#visitor">Visitor</a></p>
</li><li>
<p><a href="#visit_method">visit_method</a></p>
</li><li>
<p><a href="#language-server">Language server</a></p>
</li><li>
<p><a href="#textdocumentformatting">textDocument/formatting</a></p>
</li><li>
<p><a href="#textdocumentinlayhints">textDocument/inlayHints</a></p>
</li><li>
<p><a href="#syntaxtreevisualizing">syntaxTree/visualizing</a></p>
</li></ul>

<h2 id="label-Installation">Installation<span><a href="#label-Installation">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Syntax Tree is both a command-line interface and a library. If you’re only looking to use the command-line interface, then we recommend installing the gem globally, as in:</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-identifier">install</span> <span class="ruby-identifier">syntax_tree</span>
</pre>

<p>To run the CLI with the gem installed globally, you would run:</p>

<pre class="ruby"><span class="ruby-identifier">stree</span> <span class="ruby-identifier">version</span>
</pre>

<p>If you’re planning on using Syntax Tree as a library within your own project, we recommend installing it as part of your gem bundle. First, add this line to your application’s Gemfile:</p>

<pre class="ruby"><span class="ruby-identifier">gem</span> <span class="ruby-string">&quot;syntax_tree&quot;</span>
</pre>

<p>And then execute:</p>

<pre class="ruby"><span class="ruby-identifier">bundle</span> <span class="ruby-identifier">install</span>
</pre>

<p>To run the CLI with the gem installed in your gem bundle, you would run:</p>

<pre class="ruby"><span class="ruby-identifier">bundle</span> <span class="ruby-identifier">exec</span> <span class="ruby-identifier">stree</span> <span class="ruby-identifier">version</span>
</pre>

<h2 id="label-CLI">CLI<span><a href="#label-CLI">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Syntax Tree ships with the <code>stree</code> CLI, which can be used to inspect and manipulate Ruby code. Below are listed all of the commands built into the CLI that you can use. Note that for all commands that operate on files, you can also pass in content through STDIN.</p>

<h3 id="label-ast">ast<span><a href="#label-ast">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This command will print out a textual representation of the syntax tree associated with each of the files it finds. To execute, run:</p>

<pre class="ruby"><span class="ruby-identifier">stree</span> <span class="ruby-identifier">ast</span> <span class="ruby-identifier">path</span><span class="ruby-operator">/</span><span class="ruby-identifier">to</span><span class="ruby-operator">/</span><span class="ruby-identifier">file</span>.<span class="ruby-identifier">rb</span>
</pre>

<p>For a file that contains <code>1 + 1</code>, you will receive:</p>

<pre class="ruby">(<span class="ruby-identifier">program</span> (<span class="ruby-identifier">statements</span> (<span class="ruby-identifier">binary</span> (<span class="ruby-identifier">int</span> <span class="ruby-string">&quot;1&quot;</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">int</span> <span class="ruby-string">&quot;1&quot;</span>))))
</pre>

<h3 id="label-check">check<span><a href="#label-check">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This command is meant to be used in the context of a continuous integration or git hook. It checks each file given to make sure that it matches the expected format. It can be used to ensure unformatted content never makes it into a codebase.</p>

<pre class="ruby"><span class="ruby-identifier">stree</span> <span class="ruby-identifier">check</span> <span class="ruby-identifier">path</span><span class="ruby-operator">/</span><span class="ruby-identifier">to</span><span class="ruby-operator">/</span><span class="ruby-identifier">file</span>.<span class="ruby-identifier">rb</span>
</pre>

<p>For a file that matches the expected format, you will receive:</p>

<pre>All files matched expected format.</pre>

<p>If there are files with unformatted code, you will receive:</p>

<pre>[warn] path/to/file.rb
The listed files did not match the expected format.</pre>

<h3 id="label-format">format<span><a href="#label-format">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This command will output the formatted version of each of the listed files. Importantly, it will not write that content back to the source files. It is meant to display the formatted version only.</p>

<pre class="ruby"><span class="ruby-identifier">stree</span> <span class="ruby-identifier">format</span> <span class="ruby-identifier">path</span><span class="ruby-operator">/</span><span class="ruby-identifier">to</span><span class="ruby-operator">/</span><span class="ruby-identifier">file</span>.<span class="ruby-identifier">rb</span>
</pre>

<p>For a file that contains <code>1 + 1</code>, you will receive:</p>

<pre class="ruby"><span class="ruby-value">1</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>
</pre>

<h3 id="label-write">write<span><a href="#label-write">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This command will format the listed files and write that formatted version back to the source files. Note that this overwrites the original content, to be sure to be using a version control system.</p>

<pre class="ruby"><span class="ruby-identifier">stree</span> <span class="ruby-identifier">write</span> <span class="ruby-identifier">path</span><span class="ruby-operator">/</span><span class="ruby-identifier">to</span><span class="ruby-operator">/</span><span class="ruby-identifier">file</span>.<span class="ruby-identifier">rb</span>
</pre>

<p>This will list every file that is being formatted. It will output light gray if the file already matches the expected format. It will output in regular color if it does not.</p>

<pre>path/to/file.rb 0ms</pre>

<h2 id="label-Library">Library<span><a href="#label-Library">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Syntax Tree can be used as a library to access the syntax tree underlying Ruby source code.</p>

<h3 id="label-SyntaxTree.read-28filepath-29"><a href="SyntaxTree.html#method-c-read"><code>SyntaxTree.read(filepath)</code></a><span><a href="#label-SyntaxTree.read-28filepath-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This function takes a filepath and returns a string associated with the content of that file. It is similar in functionality to <code>File.read</code>, except htat it takes into account Ruby-level file encoding (through magic comments at the top of the file).</p>

<h3 id="label-SyntaxTree.parse-28source-29"><a href="SyntaxTree.html#method-c-parse"><code>SyntaxTree.parse(source)</code></a><span><a href="#label-SyntaxTree.parse-28source-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This function takes an input string containing Ruby code and returns the syntax tree associated with it. The top-level node is always a <code>SyntaxTree::Program</code>, which contains a list of top-level expression nodes.</p>

<h3 id="label-SyntaxTree.format-28source-29"><a href="SyntaxTree.html#method-c-format"><code>SyntaxTree.format(source)</code></a><span><a href="#label-SyntaxTree.format-28source-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>This function takes an input string containing Ruby code, parses it into its underlying syntax tree, and formats it back out to a string.</p>

<h2 id="label-Nodes">Nodes<span><a href="#label-Nodes">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>There are many different node types in the syntax tree. They are meant to be treated as immutable structs containing links to child nodes with minimal logic contained within their implementation. However, for the most part they all respond to a certain set of APIs, listed below.</p>

<h3 id="label-child_nodes">child_nodes<span><a href="#label-child_nodes">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>One of the easiest ways to descend the tree is to use the <code>child_nodes</code> function. It is implemented on every node type (leaf nodes return an empty array). If the goal is to simply walk through the tree, this is the easiest way to go.</p>

<pre class="ruby"><span class="ruby-identifier">program</span> = <span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;1 + 1&quot;</span>)
<span class="ruby-identifier">program</span>.<span class="ruby-identifier">child_nodes</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">child_nodes</span>.<span class="ruby-identifier">first</span>
<span class="ruby-comment"># =&gt; (binary (int &quot;1&quot;) :+ (int &quot;1&quot;))</span>
</pre>

<h3 id="label-Pattern+matching">Pattern matching<span><a href="#label-Pattern+matching">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Pattern matching is another way to descend the tree which is more specific than using <code>child_nodes</code>. Using Ruby’s built-in pattern matching, you can extract the same information but be as specific about your constraints as you like. For example, with minimal constraints:</p>

<pre class="ruby"><span class="ruby-identifier">program</span> = <span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;1 + 1&quot;</span>)
<span class="ruby-identifier">program</span> <span class="ruby-operator">=&gt;</span> { <span class="ruby-value">statements:</span> { <span class="ruby-value">body:</span> [<span class="ruby-identifier">binary</span>] } }
<span class="ruby-identifier">binary</span>
<span class="ruby-comment"># =&gt; (binary (int &quot;1&quot;) :+ (int &quot;1&quot;))</span>
</pre>

<p>Or, with more constraints on the types to ensure we’re getting exactly what we expect:</p>

<pre class="ruby"><span class="ruby-identifier">program</span> = <span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;1 + 1&quot;</span>)
<span class="ruby-identifier">program</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Program</span>[<span class="ruby-value">statements:</span> <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Statements</span>[<span class="ruby-value">body:</span> [<span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Binary</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">binary</span>]]]
<span class="ruby-identifier">binary</span>
<span class="ruby-comment"># =&gt; (binary (int &quot;1&quot;) :+ (int &quot;1&quot;))</span>
</pre>

<h3 id="label-pretty_print-28q-29">pretty_print(q)<span><a href="#label-pretty_print-28q-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Every node responds to the <code>pretty_print</code> Ruby interface, which makes it usable by the <code>pp</code> library. You <em>can</em> use this API manually, but it’s mostly there for compatibility and not meant to be directly invoked. For example:</p>

<pre class="ruby"><span class="ruby-identifier">pp</span> <span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;1 + 1&quot;</span>)
<span class="ruby-comment"># (program (statements (binary (int &quot;1&quot;) + (int &quot;1&quot;))))</span>
</pre>

<h3 id="label-to_json-28-2Aopts-29">to_json(*opts)<span><a href="#label-to_json-28-2Aopts-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Every node responds to the <code>to_json</code> Ruby interface, which makes it usable by the <code>json</code> library. Much like <code>pretty_print</code>, you could use this API manually, but it’s mostly used by <code>JSON</code> to dump the nodes to a serialized format. For example:</p>

<pre class="ruby"><span class="ruby-identifier">program</span> = <span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;1 + 1&quot;</span>)
<span class="ruby-identifier">program</span> <span class="ruby-operator">=&gt;</span> { <span class="ruby-value">statements:</span> { <span class="ruby-value">body:</span> [{ <span class="ruby-value">left:</span> }] } }
<span class="ruby-identifier">puts</span> <span class="ruby-constant">JSON</span>.<span class="ruby-identifier">dump</span>(<span class="ruby-identifier">left</span>)
<span class="ruby-comment"># {&quot;type&quot;:&quot;int&quot;,&quot;value&quot;:&quot;1&quot;,&quot;loc&quot;:[1,0,1,1],&quot;cmts&quot;:[]}</span>
</pre>

<h3 id="label-format-28q-29">format(q)<span><a href="#label-format-28q-29">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Every node responds to <code>format</code>, which formats the content nicely. The API mirrors that used by the <code>pretty_print</code> gem in that it accepts a formatter object and calls methods on it to generate its own internal representation of the text that will be outputted. Because of this, it’s easier to not use this API directly and instead to call <code>SyntaxTree.format</code>. You <em>can</em> however use this directly if you create the formatter yourself, as in:</p>

<pre class="ruby"><span class="ruby-identifier">source</span> = <span class="ruby-string">&quot;1+1&quot;</span>
<span class="ruby-identifier">program</span> = <span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">source</span>)
<span class="ruby-identifier">program</span> <span class="ruby-operator">=&gt;</span> { <span class="ruby-value">statements:</span> { <span class="ruby-value">body:</span> [<span class="ruby-identifier">binary</span>] } }

<span class="ruby-identifier">formatter</span> = <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Formatter</span>.<span class="ruby-identifier">new</span>(<span class="ruby-identifier">source</span>, [])
<span class="ruby-identifier">binary</span>.<span class="ruby-identifier">format</span>(<span class="ruby-identifier">formatter</span>)

<span class="ruby-identifier">formatter</span>.<span class="ruby-identifier">flush</span>
<span class="ruby-identifier">formatter</span>.<span class="ruby-identifier">output</span>.<span class="ruby-identifier">join</span>
<span class="ruby-comment"># =&gt; &quot;1 + 1&quot;</span>
</pre>

<h2 id="label-Visitor">Visitor<span><a href="#label-Visitor">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>If you want to operate over a set of nodes in the tree but don’t want to walk the tree manually, the <code>Visitor</code> class makes it easy. <code>SyntaxTree::Visitor</code> is an implementation of the double dispatch visitor pattern. It works by the user defining visit methods that process nodes in the tree, which then call back to other visit methods to continue the descent. This is easier shown in code.</p>

<p>Let’s say, for instance, that you wanted to find every place in source where you have an arithmetic problem between two integers (this is pretty contrived, but it’s just for illustration). You could define a visitor that only explicitly visited the <code>SyntaxTree::Binary</code> node, as in:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ArithmeticVisitor</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Visitor</span>
  <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_binary</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span> <span class="ruby-keyword">in</span> { <span class="ruby-value">left:</span> <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Int</span>, <span class="ruby-value">operator:</span> <span class="ruby-value">:+</span> <span class="ruby-operator">|</span> <span class="ruby-value">:-</span> <span class="ruby-operator">|</span> <span class="ruby-value">:*</span> <span class="ruby-operator">|</span> <span class="ruby-value">:/</span>, <span class="ruby-value">right:</span> <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Int</span> }
      <span class="ruby-identifier">puts</span> <span class="ruby-node">&quot;The result is: #{node.left.value.to_i.public_send(node.operator, node.right.value.to_i)}&quot;</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>

<span class="ruby-identifier">visitor</span> = <span class="ruby-constant">ArithmeticVisitor</span>.<span class="ruby-identifier">new</span>
<span class="ruby-identifier">visitor</span>.<span class="ruby-identifier">visit</span>(<span class="ruby-constant">SyntaxTree</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-string">&quot;1 + 1&quot;</span>))
<span class="ruby-comment"># The result is: 2</span>
</pre>

<p>With visitors, you only define handlers for the nodes that you need. You can find the names of the methods that you will need to define within the base visitor, as they’re all aliased to the default behavior (visiting the child nodes). Note that when you define a handler for a node, you have to tell Syntax Tree how to walk further. In the example above, we don’t need to go any further because we already know the child nodes are <code>SyntaxTree::Int</code>, so they can’t possibly contain more <code>SyntaxTree::Binary</code> nodes. In other circumstances you may not know though, so you can either:</p>
<ul><li>
<p>call <code>super</code> (which will do the default and visit all child nodes)</p>
</li><li>
<p>call <code>visit_child_nodes</code> manually</p>
</li><li>
<p>call <code>visit(child)</code> with each child that you want to visit</p>
</li><li>
<p>call nothing if you’re sure you don’t want to descend further</p>
</li></ul>

<h3 id="label-visit_method">visit_method<span><a href="#label-visit_method">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>When you’re creating a visitor, it’s very easy to accidentally mistype a visit method. Unfortunately, there’s no way to tell Ruby to explicitly override a parent method, so it would then be easy to define a method that never gets called. To mitigate this risk, there’s <code>Visitor.visit_method(name)</code>. This method accepts a symbol that is checked against the list of know visit methods. If it’s not in the list, then an error will be raised. It’s meant to be used like:</p>

<pre class="ruby"><span class="ruby-keyword">class</span> <span class="ruby-constant">ArithmeticVisitor</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">SyntaxTree</span><span class="ruby-operator">::</span><span class="ruby-constant">Visitor</span>
  <span class="ruby-identifier">visit_method</span> <span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">visit_binar</span>(<span class="ruby-identifier">node</span>)
    <span class="ruby-comment"># ...</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span>
</pre>

<p>This will only be checked once when the file is first required. If there is a typo in your method name (or the method no longer exists for whatever reason), you will receive an error like so:</p>

<pre>~/syntax_tree/lib/syntax_tree/visitor.rb:46:in `visit_method&#39;: Invalid visit method: visit_binar (SyntaxTree::Visitor::VisitMethodError)
Did you mean?  visit_binary
               visit_in
               visit_ivar
        from (irb):2:in `&lt;class:ArithmeticVisitor&gt;&#39;
        from (irb):1:in `&lt;main&gt;&#39;
        from bin/console:8:in `&lt;main&gt;&#39;</pre>

<h2 id="label-Language+server">Language server<span><a href="#label-Language+server">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Syntax Tree additionally ships with a language server conforming to the <a href="https://microsoft.github.io/language-server-protocol/">language server protocol</a>. It can be invoked through the CLI by running:</p>

<pre class="ruby"><span class="ruby-identifier">stree</span> <span class="ruby-identifier">lsp</span>
</pre>

<p>By default, the language server is relatively minimal, mostly meant to provide a registered formatter for the Ruby language. However there are a couple of additional niceties baked in. There are related projects that configure and use this language server within IDEs. For example, to use this code with VSCode, see <a href="https://github.com/ruby-syntax-tree/vscode-syntax-tree">ruby-syntax-tree/vscode-syntax-tree</a>.</p>

<h3 id="label-textDocument-2Fformatting">textDocument/formatting<span><a href="#label-textDocument-2Fformatting">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>As mentioned above, the language server responds to formatting requests with the formatted document. It typically responds on the order of tens of milliseconds, so it should be fast enough for any IDE.</p>

<h3 id="label-textDocument-2FinlayHints">textDocument/inlayHints<span><a href="#label-textDocument-2FinlayHints">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The language server also responds to the relatively new inlay hints request. This request allows the language server to define additional information that should exist in the source code as helpful hints to the developer. In our case we use it to display things like implicit parentheses. For example, if you had the following code:</p>

<pre class="ruby"><span class="ruby-value">1</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span>
</pre>

<p>Implicity, the <code>2 * 3</code> is going to be executed first because the <code>*</code> operator has higher precedence than the <code>+</code> operator. However, to ease mental overhead, our language server includes small parentheses to make this explicit, as in:</p>

<pre class="ruby"><span class="ruby-value">1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">₍2</span> <span class="ruby-operator">*</span> <span class="ruby-value">3</span><span class="ruby-identifier">₎</span>
</pre>

<h3 id="label-syntaxTree-2Fvisualizing">syntaxTree/visualizing<span><a href="#label-syntaxTree-2Fvisualizing">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The language server additionally includes this custom request to return a textual representation of the syntax tree underlying the source code of a file. Language server clients can use this to (for example) open an additional tab with this information displayed.</p>

<h2 id="label-Development">Development<span><a href="#label-Development">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>After checking out the repo, run <code>bin/setup</code> to install dependencies. Then, run <code>rake test</code> to run the tests. You can also run <code>bin/console</code> for an interactive prompt that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bundle exec rake install</code>. To release a new version, update the version number in <code>version.rb</code>, and then run <code>bundle exec rake release</code>, which will create a git tag for the version, push git commits and tags, and push the <code>.gem</code> file to <a href="https://rubygems.org">rubygems.org</a>.</p>

<h2 id="label-Contributing">Contributing<span><a href="#label-Contributing">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>Bug reports and pull requests are welcome on GitHub at <a href="https://github.com/ruby-syntax-tree/syntax_tree">github.com/ruby-syntax-tree/syntax_tree</a>.</p>

<h2 id="label-License">License<span><a href="#label-License">&para;</a> <a href="#top">&uarr;</a></span></h2>

<p>The gem is available as open source under the terms of the <a href="https://opensource.org/licenses/MIT">MIT License</a>.</p>

</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.4.0.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

